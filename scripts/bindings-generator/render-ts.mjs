import { methodKey } from "./signature.mjs";
import { toTsType } from "./type-utils.mjs";

function escapeJsDoc(value) {
  return value.replace(/\*\//g, "*\\/");
}

function renderJsDocLines(method) {
  const descriptionLines = method.jsDoc?.descriptionLines ?? [];
  const paramDocs = method.jsDoc?.paramDocs ?? [];
  const returns = method.jsDoc?.returns ?? "";

  if (descriptionLines.length === 0 && paramDocs.length === 0 && !returns) {
    return [];
  }

  const lines = ["  /**"];

  for (const line of descriptionLines) {
    lines.push(`   * ${escapeJsDoc(line)}`);
  }

  for (const paramDoc of paramDocs) {
    lines.push(`   * @param ${paramDoc.name} ${escapeJsDoc(paramDoc.text)}`);
  }

  if (returns) {
    lines.push(`   * @returns ${escapeJsDoc(returns)}`);
  }

  lines.push("   */");
  return lines;
}

function renderTsTypeMaps(typeMetadata) {
  const lines = [];

  const allTypeMaps = [...typeMetadata.enumDefs, ...typeMetadata.flagDefs];
  for (const typeMap of allTypeMaps) {
    lines.push(`export const ${typeMap.tsName} = {`);
    for (const member of typeMap.members) {
      lines.push(`  ${member.name}: ${member.value},`);
    }
    lines.push("} as const;");

    if (typeMap.kind === "flags") {
      lines.push(`export type ${typeMap.tsName} = number;`);
      lines.push(`export type ${typeMap.tsName}Flag = (typeof ${typeMap.tsName})[keyof typeof ${typeMap.tsName}];`);
    } else {
      lines.push(`export type ${typeMap.tsName} = (typeof ${typeMap.tsName})[keyof typeof ${typeMap.tsName}];`);
    }

    lines.push("");
  }

  return lines;
}

export function renderTsInterface(methods, typeMetadata) {
  const lines = [
    "// Generated by scripts/generate-fgfdmexec-bindings.mjs.",
    "// Do not edit manually.",
    "",
    "export type OpaqueHandle = number;",
    ""
  ];

  lines.push(...renderTsTypeMaps(typeMetadata));
  lines.push("export interface FGFDMExecApi {");

  for (const method of methods) {
    const key = methodKey(method);
    const methodParamOverrides = typeMetadata.paramTypeOverrides.get(key);

    lines.push(...renderJsDocLines(method));

    const params = method.params
      .map((param, index) => {
        const paramOverride = methodParamOverrides?.get(index);
        const typeName = paramOverride ?? toTsType(param.type, { enumLookup: typeMetadata.enumLookup });
        const optionalToken = param.defaultValue !== null ? "?" : "";
        return `${param.name}${optionalToken}: ${typeName}`;
      })
      .join(", ");

    const returnType = typeMetadata.returnTypeOverrides.get(key) ?? toTsType(method.returnType, {
      enumLookup: typeMetadata.enumLookup,
      isReturn: true
    });

    lines.push(`  ${method.name}(${params}): ${returnType};`);
  }

  lines.push("}", "");
  return lines.join("\n");
}
