import {
  baseTypeForPointerCast,
  isBoolType,
  isNumericType,
  isPointerType,
  isReferenceType,
  isSGPathType,
  isStringType,
  normalizeType,
  qualifyCppType,
  resolveEnumInfo,
  stripConstVolatile
} from "./type-utils.mjs";

function toCppParamType(paramType, enumLookup) {
  if (resolveEnumInfo(paramType, enumLookup)) return "int";
  if (isBoolType(paramType)) return "bool";
  if (isNumericType(paramType)) return stripConstVolatile(paramType).replace(/[&*]/g, "").trim();
  if (isStringType(paramType) || isSGPathType(paramType)) return "const std::string&";
  return "uintptr_t";
}

function convertCppArg(paramType, argName, enumLookup) {
  const enumInfo = resolveEnumInfo(paramType, enumLookup);
  if (enumInfo) {
    return `static_cast<${enumInfo.cppQualifiedName}>(${argName})`;
  }

  if (isBoolType(paramType) || isNumericType(paramType) || isStringType(paramType)) {
    return argName;
  }

  if (isSGPathType(paramType)) {
    return `SGPath(${argName})`;
  }

  if (isPointerType(paramType)) {
    const castType = qualifyCppType(normalizeType(paramType));
    return `reinterpret_cast<${castType}>(${argName})`;
  }

  if (isReferenceType(paramType)) {
    const baseType = qualifyCppType(baseTypeForPointerCast(paramType));
    if (/\bconst\b/.test(paramType)) {
      return `*reinterpret_cast<const ${baseType}*>(${argName})`;
    }
    return `*reinterpret_cast<${baseType}*>(${argName})`;
  }

  const baseType = qualifyCppType(baseTypeForPointerCast(paramType));
  return `*reinterpret_cast<${baseType}*>(${argName})`;
}

function renderWrapperFunctions(methods, enumLookup) {
  return methods
    .map((method, methodIndex) => {
      const wrapperName = `wrap_FGFDMExec_${method.name}_${methodIndex}`;
      const params = method.params
        .map((param) => `${toCppParamType(param.type, enumLookup)} ${param.name}`)
        .join(", ");

      const convertedArgs = method.params
        .map((param) => convertCppArg(param.type, param.name, enumLookup))
        .join(", ");

      const invoke = `self.${method.name}(${convertedArgs})`;
      const returnType = method.returnType === "void" ? "void" : "auto";
      const callLine = method.returnType === "void"
        ? `  ${invoke};`
        : `  return toJsValue(${invoke});`;

      return `static ${returnType} ${wrapperName}(FGFDMExec& self${params ? `, ${params}` : ""}) {\n${callLine}\n}`;
    })
    .join("\n\n");
}

function renderBindingRegistration(methods) {
  const lines = [
    "EMSCRIPTEN_BINDINGS(jsbsim_fgfmdexec_bindings) {",
    '  emscripten::class_<FGFDMExec>("FGFDMExec")',
    "    .constructor<>()"
  ];

  methods.forEach((method, methodIndex) => {
    const wrapperName = `wrap_FGFDMExec_${method.name}_${methodIndex}`;
    lines.push(`    .function("${method.name}", &${wrapperName})`);
  });

  lines[lines.length - 1] += ";";
  lines.push("}");
  return lines.join("\n");
}

export function renderCppOutput(methods, enumLookup, sourceHeaderRelPath = "FGFDMExec.h") {
  const wrappers = renderWrapperFunctions(methods, enumLookup);
  const bindings = renderBindingRegistration(methods);

  return `// Generated by scripts/generate-fgfdmexec-bindings.mjs.\n// Do not edit manually.\n\n#include <cstdint>\n#include <memory>\n#include <string>\n#include <type_traits>\n#include <vector>\n\n#include <emscripten/bind.h>\n#include <emscripten/val.h>\n\n#include "${sourceHeaderRelPath}"\n\nnamespace {\n\nusing JSBSim::FGFDMExec;\nusing ::SGPath;\n\ntemplate <typename T>\nstd::enable_if_t<std::is_arithmetic_v<T>, T> toJsValue(T value) {\n  return value;\n}\n\ntemplate <typename T>\nstd::enable_if_t<std::is_enum_v<T>, int> toJsValue(T value) {\n  return static_cast<int>(value);\n}\n\ninline std::string toJsValue(const std::string& value) {\n  return value;\n}\n\ninline std::string toJsValue(std::string&& value) {\n  return std::move(value);\n}\n\ninline std::string toJsValue(const SGPath& path) {\n  return path.utf8Str();\n}\n\ninline emscripten::val toJsValue(const std::vector<std::string>& values) {\n  emscripten::val out = emscripten::val::array();\n  for (std::size_t i = 0; i < values.size(); ++i) {\n    out.set(i, values[i]);\n  }\n  return out;\n}\n\ninline emscripten::val toJsValue(std::vector<std::string>& values) {\n  return toJsValue(static_cast<const std::vector<std::string>&>(values));\n}\n\ntemplate <typename T>\nuintptr_t toJsValue(T* value) {\n  return reinterpret_cast<uintptr_t>(value);\n}\n\ntemplate <typename T>\nuintptr_t toJsValue(const std::shared_ptr<T>& value) {\n  return reinterpret_cast<uintptr_t>(value.get());\n}\n\ntemplate <typename T>\nuintptr_t toJsValue(const std::unique_ptr<T>& value) {\n  return reinterpret_cast<uintptr_t>(value.get());\n}\n\ntemplate <typename T>\nuintptr_t toJsValue(T& value) {\n  return reinterpret_cast<uintptr_t>(&value);\n}\n\n${wrappers}\n\n}  // namespace\n\n${bindings}\n`;
}
