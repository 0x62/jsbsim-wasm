// Generated by scripts/generate-fgfdmexec-bindings.mjs.
// Do not edit manually.

import type { FGFDMExecApi, ResetToInitialConditionsMode, TrimMode } from "./fgfdmexec-api";

export class JSBSimApi {
  readonly exec: FGFDMExecApi;

  constructor(exec: FGFDMExecApi) {
    this.exec = exec;
  }

  /**
   * Unbind all tied JSBSim properties.
   */
  unbind(): void {
    this.exec.Unbind();
  }

  /**
   * This function executes each scheduled model in succession.
   * @returns true if successful, false if sim should be ended
   */
  run(): boolean {
    return this.exec.Run();
  }

  /**
   * Initializes the sim from the initial condition object and executes each scheduled model without integrating i.e. dt=0.
   * @returns true if successful
   */
  runIc(): boolean {
    return this.exec.RunIC();
  }

  /**
   * Loads the planet. Loads the definition of the planet on which the vehicle will evolve such as its radius, gravity or its atmosphere characteristics.
   * @param PlanetPath The name of a planet definition file
   * @param useAircraftPath true if path is given relative to the aircraft path.
   * @returns true if successful
   */
  loadPlanet(PlanetPath: string, useAircraftPath: boolean = true): boolean {
    return this.exec.LoadPlanet(PlanetPath, useAircraftPath);
  }

  /**
   * Loads an aircraft model.
   * @param AircraftPath path to the aircraft/ directory. For instance: "aircraft". Under aircraft, then, would be directories for various modeled aircraft such as C172/, x15/, etc.
   * @param EnginePath path to the directory under which engine config files are kept, for instance "engine"
   * @param SystemsPath path to the directory under which systems config files are kept, for instance "systems"
   * @param model the name of the aircraft model itself. This file will be looked for in the directory specified in the AircraftPath variable, and in turn under the directory with the same name as the model. For instance: "aircraft/x15/x15.xml"
   * @param addModelToPath set to true to add the model name to the AircraftPath, defaults to true
   * @returns true if successful
   */
  loadModel(AircraftPath: string, EnginePath: string, SystemsPath: string, model: string, addModelToPath?: boolean): boolean;
  /**
   * Loads an aircraft model. The paths to the aircraft and engine config file directories must be set prior to calling this. See below.
   * @param model the name of the aircraft model itself. This file will be looked for in the directory specified in the AircraftPath variable, and in turn under the directory with the same name as the model. For instance: "aircraft/x15/x15.xml"
   * @param addModelToPath set to true to add the model name to the AircraftPath, defaults to true
   * @returns true if successful
   */
  loadModel(model: string, addModelToPath?: boolean): boolean;
  loadModel(...args: unknown[]): boolean {
    const normalizedArgs = [...args] as unknown[];
    switch (normalizedArgs.length) {
      case 1:
        normalizedArgs.push(true);
        break;
      case 4:
        normalizedArgs.push(true);
        break;
      default:
        break;
    }
    return (this.exec.LoadModel as (...innerArgs: unknown[]) => boolean)(...normalizedArgs);
  }

  /**
   * Load a script
   * @param Script The full path name and file name for the script to be loaded.
   * @param deltaT The simulation integration step size, if given. If no value is supplied then 0.0 is used and the value is expected to be supplied in the script file itself.
   * @param initfile The initialization file that will override the initialization file specified in the script file. If no file name is given on the command line, the file specified in the script will be used. If an initialization file is not given in either place, an error will result.
   * @returns true if successfully loads; false otherwise.
   */
  loadScript(Script: string, deltaT: number = 0, initfile: string = ""): boolean {
    return this.exec.LoadScript(Script, deltaT, initfile);
  }

  /**
   * Set the path to the engine config file directories. Relative paths are taken from the root directory.
   * @param path path to the directory under which engine config files are kept, for instance "engine".
   */
  setEnginePath(path: string): boolean {
    return this.exec.SetEnginePath(path);
  }

  /**
   * Set the path to the aircraft config file directories. Under this path, then, would be directories for various modeled aircraft such as C172/, x15/, etc. Relative paths are taken from the root directory.
   * @param path path to the aircraft directory, for instance "aircraft".
   */
  setAircraftPath(path: string): boolean {
    return this.exec.SetAircraftPath(path);
  }

  /**
   * Set the path to the systems config file directories. Relative paths are taken from the root directory.
   * @param path path to the directory under which systems config files are kept, for instance "systems"
   */
  setSystemsPath(path: string): boolean {
    return this.exec.SetSystemsPath(path);
  }

  /**
   * Set the directory where the output files will be written. Relative paths are taken from the root directory.
   * @param path path to the directory under which the output files will be written.
   */
  setOutputPath(path: string): boolean {
    return this.exec.SetOutputPath(path);
  }

  /**
   * Returns the FGAtmosphere pointer.
   */
  getAtmosphere(): number {
    return this.exec.GetAtmosphere();
  }

  /**
   * Returns the FGAccelerations pointer.
   */
  getAccelerations(): number {
    return this.exec.GetAccelerations();
  }

  /**
   * Returns the FGWinds pointer.
   */
  getWinds(): number {
    return this.exec.GetWinds();
  }

  /**
   * Returns the FGFCS pointer.
   */
  getFcs(): number {
    return this.exec.GetFCS();
  }

  /**
   * Returns the FGPropulsion pointer.
   */
  getPropulsion(): number {
    return this.exec.GetPropulsion();
  }

  /**
   * Returns the FGAircraft pointer.
   */
  getMassBalance(): number {
    return this.exec.GetMassBalance();
  }

  /**
   * Returns the FGAerodynamics pointer
   */
  getAerodynamics(): number {
    return this.exec.GetAerodynamics();
  }

  /**
   * Returns the FGInertial pointer.
   */
  getInertial(): number {
    return this.exec.GetInertial();
  }

  /**
   * Returns the FGGroundReactions pointer.
   */
  getGroundReactions(): number {
    return this.exec.GetGroundReactions();
  }

  /**
   * Returns the FGExternalReactions pointer.
   */
  getExternalReactions(): number {
    return this.exec.GetExternalReactions();
  }

  /**
   * Returns the FGBuoyantForces pointer.
   */
  getBuoyantForces(): number {
    return this.exec.GetBuoyantForces();
  }

  /**
   * Returns the FGAircraft pointer.
   */
  getAircraft(): number {
    return this.exec.GetAircraft();
  }

  /**
   * Returns the FGPropagate pointer.
   */
  getPropagate(): number {
    return this.exec.GetPropagate();
  }

  /**
   * Returns the FGAuxiliary pointer.
   */
  getAuxiliary(): number {
    return this.exec.GetAuxiliary();
  }

  /**
   * Returns the FGInput pointer.
   */
  getInput(): number {
    return this.exec.GetInput();
  }

  /**
   * Returns the FGOutput pointer.
   */
  getOutput(): number {
    return this.exec.GetOutput();
  }

  /**
   * Retrieves the script object
   */
  getScript(): number {
    return this.exec.GetScript();
  }

  /**
   * Returns a pointer to the FGInitialCondition object
   */
  getIc(): number {
    return this.exec.GetIC();
  }

  /**
   * Returns a pointer to the FGTrim object
   */
  getTrim(): number {
    return this.exec.GetTrim();
  }

  /**
   * Retrieves the engine path.
   */
  getEnginePath(): string {
    return this.exec.GetEnginePath();
  }

  /**
   * Retrieves the aircraft path.
   */
  getAircraftPath(): string {
    return this.exec.GetAircraftPath();
  }

  /**
   * Retrieves the systems path.
   */
  getSystemsPath(): string {
    return this.exec.GetSystemsPath();
  }

  /**
   * Retrieves the full aircraft path name.
   */
  getFullAircraftPath(): string {
    return this.exec.GetFullAircraftPath();
  }

  /**
   * Retrieves the path to the output files.
   */
  getOutputPath(): string {
    return this.exec.GetOutputPath();
  }

  /**
   * Retrieves the value of a property.
   * @param property the name of the property
   */
  getPropertyValue(property: string): number {
    return this.exec.GetPropertyValue(property);
  }

  /**
   * Sets a property value.
   * @param property the property to be set
   * @param value the value to set the property to
   */
  setPropertyValue(property: string, value: number): void {
    this.exec.SetPropertyValue(property, value);
  }

  /**
   * Returns the model name.
   */
  getModelName(): string {
    return this.exec.GetModelName();
  }

  /**
   * Returns a pointer to the property manager object.
   */
  getPropertyManager(): number {
    return this.exec.GetPropertyManager();
  }

  /**
   * Returns a vector of strings representing the names of all loaded models (future)
   */
  enumerateFdms(): string[] {
    return this.exec.EnumerateFDMs();
  }

  /**
   * Gets the number of child FDMs.
   */
  getFdmCount(): number {
    return this.exec.GetFDMCount();
  }

  /**
   * Gets a particular child FDM.
   */
  getChildFdm(i: number): number {
    return this.exec.GetChildFDM(i);
  }

  /**
   * Marks this instance of the Exec object as a "child" object.
   */
  setChild(ch: boolean): void {
    this.exec.SetChild(ch);
  }

  /**
   * Sets the output (logging) mechanism for this run. Calling this function passes the name of an output directives file to the FGOutput object associated with this run. The call to this function should be made prior to loading an aircraft model. This call results in an FGOutput object being built as the first Output object in the FDMExec-managed list of Output objects that may be created for an aircraft model. If this call is made after an aircraft model is loaded, there is no effect. Any Output objects added by the aircraft model itself (in an < output> element) will be added after this one. Care should be taken not to refer to the same file name. An output directives file contains an < output> < /output> element, within which should be specified the parameters or parameter groups that should be logged.
   * @param fname the filename of an output directives file.
   */
  setOutputDirectives(fname: string): boolean {
    return this.exec.SetOutputDirectives(fname);
  }

  /**
   * Forces the specified output object to print its items once
   */
  forceOutput(idx: number = 0): void {
    this.exec.ForceOutput(idx);
  }

  /**
   * Sets the logging rate in Hz for all output objects (if any).
   */
  setLoggingRate(rate: number): void {
    this.exec.SetLoggingRate(rate);
  }

  /**
   * Executes trimming in the selected mode.
   * @param mode Specifies how to trim: - tLongitudinal=0 - tFull - tGround - tPullup - tCustom - tTurn - tNone
   */
  doTrim(mode: TrimMode): void {
    this.exec.DoTrim(mode);
  }

  /**
   * Executes linearization with state-space output You must trim first to get an accurate state-space model
   */
  doLinearization(arg0: number): void {
    this.exec.DoLinearization(arg0);
  }

  /**
   * Disables data logging to all outputs.
   */
  disableOutput(): void {
    this.exec.DisableOutput();
  }

  /**
   * Enables data logging to all outputs.
   */
  enableOutput(): void {
    this.exec.EnableOutput();
  }

  /**
   * Pauses execution by preventing time from incrementing.
   */
  hold(): void {
    this.exec.Hold();
  }

  /**
   * Turn on hold after increment
   */
  enableIncrementThenHold(Timesteps: number): void {
    this.exec.EnableIncrementThenHold(Timesteps);
  }

  /**
   * Checks if required to hold afer increment
   */
  checkIncrementalHold(): void {
    this.exec.CheckIncrementalHold();
  }

  /**
   * Resumes execution from a "Hold".
   */
  resume(): void {
    this.exec.Resume();
  }

  /**
   * Returns true if the simulation is Holding (i.e. simulation time is not moving).
   */
  holding(): boolean {
    return this.exec.Holding();
  }

  /**
   * Resets the initial conditions object and prepares the simulation to run again. If the mode's first bit is set the output instances will take special actions such as closing the current output file and open a new one with a different name. If the second bit is set then RunIC() won't be executed, leaving it to the caller to call RunIC(), e.g. in case the caller wants to set some other state like control surface deflections which would've been reset.
   * @param mode Sets the reset mode.
   */
  resetToInitialConditions(mode: ResetToInitialConditionsMode): void {
    this.exec.ResetToInitialConditions(mode);
  }

  /**
   * Sets the debug level.
   */
  setDebugLevel(level: number): void {
    this.exec.SetDebugLevel(level);
  }

  /**
   * Builds a catalog of properties. This function descends the property tree and creates a list (an STL vector) containing the name and node for all properties.
   * @param pcs The "root" property catalog structure pointer.
   */
  buildPropertyCatalog(pcs: number): void {
    this.exec.BuildPropertyCatalog(pcs);
  }

  /**
   * Retrieves property or properties matching the supplied string. A string is returned that contains a carriage return delimited list of all strings in the property catalog that matches the supplied check string.
   * @param check The string to search for in the property catalog.
   * @param end_of_line End of line (CR+LF if needed for Windows).
   * @returns the carriage-return-delimited string containing all matching strings in the catalog.
   */
  queryPropertyCatalog(check: string, end_of_line: string = "\n"): string {
    return this.exec.QueryPropertyCatalog(check, end_of_line);
  }

  printPropertyCatalog(): void {
    this.exec.PrintPropertyCatalog();
  }

  printSimulationConfiguration(): void {
    this.exec.PrintSimulationConfiguration();
  }

  getPropertyCatalog(): string[] {
    return this.exec.GetPropertyCatalog();
  }

  setTrimStatus(status: boolean): void {
    this.exec.SetTrimStatus(status);
  }

  getTrimStatus(): boolean {
    return this.exec.GetTrimStatus();
  }

  setTrimMode(mode: TrimMode): void {
    this.exec.SetTrimMode(mode);
  }

  getTrimMode(): TrimMode {
    return this.exec.GetTrimMode();
  }

  getPropulsionTankReport(): string {
    return this.exec.GetPropulsionTankReport();
  }

  /**
   * Returns the cumulative simulation time in seconds.
   */
  getSimTime(): number {
    return this.exec.GetSimTime();
  }

  /**
   * Returns the simulation delta T.
   */
  getDeltaT(): number {
    return this.exec.GetDeltaT();
  }

  /**
   * Suspends the simulation and sets the delta T to zero.
   */
  suspendIntegration(): void {
    this.exec.SuspendIntegration();
  }

  /**
   * Resumes the simulation by resetting delta T to the correct value.
   */
  resumeIntegration(): void {
    this.exec.ResumeIntegration();
  }

  /**
   * Returns the simulation suspension state.
   * @returns true if suspended, false if executing
   */
  integrationSuspended(): boolean {
    return this.exec.IntegrationSuspended();
  }

  /**
   * Sets the current sim time.
   * @param cur_time the current time
   * @returns the current simulation time.
   */
  setSimTime(cur_time: number): number {
    return this.exec.Setsim_time(cur_time);
  }

  /**
   * Sets the integration time step for the simulation executive.
   * @param delta_t the time step in seconds.
   */
  setDt(delta_t: number): void {
    this.exec.Setdt(delta_t);
  }

  /**
   * Set the root directory that is used to obtain absolute paths from relative paths. Aircraft, engine, systems and output paths are not updated by this method. You must call each methods (SetAircraftPath(), SetEnginePath(), etc.) individually if you need to update these paths as well.
   * @param rootDir the path to the root directory.
   */
  setRootDir(rootDir: string): void {
    this.exec.SetRootDir(rootDir);
  }

  /**
   * Retrieve the Root Directory.
   * @returns the path to the root (base) JSBSim directory.
   */
  getRootDir(): string {
    return this.exec.GetRootDir();
  }

  /**
   * Increments the simulation time if not in Holding mode. The Frame counter is also incremented.
   * @returns the new simulation time.
   */
  incrTime(): number {
    return this.exec.IncrTime();
  }

  /**
   * Retrieves the current frame count.
   */
  getFrame(): number {
    return this.exec.GetFrame();
  }

  /**
   * Retrieves the current debug level setting.
   */
  getDebugLevel(): number {
    return this.exec.GetDebugLevel();
  }

  /**
   * Initializes the simulation with initial conditions
   * @param FGIC The initial conditions that will be passed to the simulation.
   */
  initialize(FGIC: number): void {
    this.exec.Initialize(FGIC);
  }

  /**
   * Sets the property forces/hold-down. This allows to do hard 'hold-down' such as for rockets on a launch pad with engines ignited.
   * @param hd enables the 'hold-down' function if non-zero
   */
  setHoldDown(hd: boolean): void {
    this.exec.SetHoldDown(hd);
  }

  /**
   * Gets the value of the property forces/hold-down.
   */
  getHoldDown(): boolean {
    return this.exec.GetHoldDown();
  }

  getTemplateFunc(name: string): number {
    return this.exec.GetTemplateFunc(name);
  }

  addTemplateFunc(name: string, el: number): void {
    this.exec.AddTemplateFunc(name, el);
  }

  getRandomGenerator(): number {
    return this.exec.GetRandomGenerator();
  }

  sRand(): number {
    return this.exec.SRand();
  }

}